== Command Line functions ==

Almost every command line program needs to parse its supplied arguments. The
Windows world tends to use one big string, letting programmers implement their
own parser. In the Unix world, the getopt() API is the reference. None of them
are easy to use and functional.

The SCElib command line parsing utility tries to give programmers a quick and
natural way to manage command line options, via an opaque command line object
and a callback system.

First create a cmdline_t object, then assign options with their restrictions,
and call cmdline_parse(). For each discovered option (previously defined or
not), the parser will call your callback function.

1. Managing the command line object
===================================

cmdline_t cmdline_create()
--------------------------

cmdline_t cmdline_create(int flags, cmdline_cb_t callback);

Creates a command line object and return it. The callback parameter is a
default one, when no defined option was found or no specific callback function
has been declared for a defined option. You can pass NULL as callback
parameter to avoid being called in another way than for a specific option
(see more about callbacks in options definition below).

The flags control the command line object behaviour:
CMDF_ENDMARK	Indicates that the -- will be treated as an 'end of options'
				marker. Subsequent command line parameters will all be reported
				as simple arguments, even if they conform to the option style.

CMDF_DASHSHORT	The '-x' (a dash and one letter or digit) is reported as an
				option.

CMDF_DASHLONG	The '-long' (a dash and several letters and/or digits) is
				reported as an option.

CMDF_DDASHLONG	The '--long' (a double dash and several letters and/or digits)
				is reported as an option.

CMDF_SLASHSHORT	The '/x' (a slash and one letter or digit) is reported as an
				option.

CMDF_SLASHLONG	The '/long' (a slash and several letters and/or digits) is
				reported as an option.

CMDF_EQUALSHORT	'<option>=arg' (argument separated from the option by an equal
				sign) is reported as an option for short (one letter or digit)
				options.

CMDF_EQUALLONG	'<option>=arg' (argument separated from the option by an equal
				sign) is reported as an option for long (several letters and/or
				digits) options.

CMDF_SPACESHORT '<option> arg' (argument separated from the option by a space)
				is reported as an option for short (one letter or digit)
				options.

CMDF_SPACELONG	'<option> arg' (argument separated from the option by a space)
				is reported as an option for long (several letters and/or
				digits) options.

CMDF_ONLYDEFS	Report only defined options as such ones. Non defined options
				are reported as simple arguments.

CMDF_GNUSTYLE	Shortcut for standard GNU (and for the most part *nix) syntax:
				-x
				-x arg
				--long
				--long=arg

CMDF_WINSTYLE	Shortcut for standard Windows syntax:
				/x
				/x arg
				/long
				/long arg

CMDF_JAVASTYLE	Shortcut for syntax used in Java (and many other) programs:
				-x
				-x arg
				-long
				-long arg

CMDF_STDSTYLE	Dependant on the platform. Will be CMDF_GNUSTYLE on *nix and
				CMDF_WINSTYLE on Windows.

cmdline_destroy()
-----------------

int cmdline_destroy(cmdline_t cmd);

Destroys a previously allocated cmdline_t object, freeing all internal datas
too. Call it after parsing if you don't need any reference to the command line
object.
Returns 0 if all is ok, -1 otherwise (see errno).

2. Parsing the command line
===========================

The parser
----------

Its scheme is quiet simple. It navigate through the actual arguments passed on
the command line, and check for each if an option was defined. If it's not the
case and a default callback function was specified (with cmdline_create()),
it'll call it. If a defined option is detected, it'll call the option specific
callback like for non defined options. You can use a specific callback for each
option, use a generic one, or a shared one for some options, at your choice,
you can completly manage the way you handle options.
In this callback, you've to return a value: 0 to indicate to continue the
parsing (for example if you detected an error) or a non zero value to stop. The
parser will return the last called callback return value. As the parser returns
-1 in case of internal error, you should avoid using this value in callback
returns (use instead a positive value).

The cmdline_cb_t function pointer
---------------------------------

typedef int (*cmdline_cb_t)(cmdline_t cl, cmdparsed_t *parsed, void *userdata);

typedef int (*cmdparse_cb)(cmdline_t cmd, cmdparsed_t *parsed, void *userdata);

Your callback(s) must have this prorotype. For each call, you'll have access to
the command line object (to retrieve option information for example), a simple
cmdparsed_t structure pointer, in which you'll find all revelant information
about the actual argument, and a pointer to user data you've previously passed
to the parser function (this's a quick way to keep state information, you can
use it to store you're detected options for example, without the need of
global variables - global variables are devil).

The cmdparsed_t type
--------------------

typedef struct cmdparsed_type cmdparsed_t;
struct cmdparsed_type
{
	int opt_pos;	/* position on command line */
	char *opt_name;	/* option name, without prefix */
	char *opt_arg;	/* argument, if specified, NULL otherwise */

	int optid;		/* reference to option id, -1 if not a defined one */
};

For each call of your callback function, a new cmdparsed_t object will be given
as option information. In this structure, you'll find generic options fields:
* 'opt_pos' is the option position on command line (index of argv)
* 'opt_name' is the actual option name (of course), without the leading prefix
  (one or two dashes, or a slash). It's NULL if the command line parameter is
  not an option (argument alone).
* 'opt_arg' is the detected argument attached to the option, if found (NULL
  otherwise).

You can detect if the call is for defined options or not, by checking the
'optid' field. 'optid' is the index to the defined option in the cmdline_t
object, or -1 if the parser didn't detect one for this command line argument.

When the parser looks for options and find one, it checks its style and report
it really as an option if the style is correct, or as a simple argument if not.

Parsing
-------

Use the simple function

int cmdline_parse(cmdline_t cl, int argc, char **argv, void* userdata);

You pass it your cmdline_t object, the argc/arcv pair, and optionaly a user
data that will be transmitted to your callbacks. It returns -1 if and error
occurred (check errno to know more), or the return value of the last called
callback.

3. Adding options
=================

When you have a cmdline_t object, you can assign to it options that will be
checked by the parser. The options representation is internal to the utility,
which great simplifies the interface.
Defining options isn't mandatory (this utility can be used just as a quick
command line callback scheme), but you'll miss all its interest.

cmdline_addopt()
----------------

int cmdline_addopt(cmdline_t cl, char sname, char *lname,
				   cmdline_cb_t callback);

Defines a new option with the short (one character) name 'sname', or 0 if you
don't want this option to have a short name; the long name 'lname', or NULL if
you don't want this option to have a long name. Finally, you can pass a callback
function as describe above. The return value is the option index in the array of
options (the one used to initialize the 'optid' field of the cmdparsed_t
structure).

cmdline_addopt_if()
-------------------

int cmdline_addopt_if(cmdline_t cl, char sname, char *lname,
					  cmdline_cb_t callback, int pred);

Defines an option like cmdline_addopt(), but only if the predicate 'pred'
evaluates to a value different than zero.

4. Other utility functions
==========================

cmdline_getopt()
----------------

int cmdline_getopt(cmdline_t cl, int optid, char *sname, char **lname);

This function returns the information of the option pointed by the cmdline_t
object and the option index (optid). Will return 0 if all is Ok or -1 when an
error occurred (essentialy EINVAL for bad option referencing).
Don't use buffers or free returned buffers. The returned pointers point to
allocated memory locations. For example:

char sname;
char *lname;
cmdline_getopt(cl, 0, &sname, &lname);
/* do anything */
cmdline_getopt(cl, 1, &sname, &lname);
/* ... */

cmdline_print()
---------------

**NOT IMPLEMENTED YET**

void cmdline_print(FILE *fd, cmdline_t cl, char *head, char *tail);

This function is a cool utility which implements for you a 'usage' help. It
will enumerate all defined options (in their creation order), with the
associated help if you gave one to them, in a 'standard' (aka GNU'like) format.

You can specify an 'head' which will be output before the enumeration, and a
'tail' which will be output ... after :-). You specify the output stream with
the 'fd' parameter (making this function versatile enough to output on STDERR
or even in a file).
